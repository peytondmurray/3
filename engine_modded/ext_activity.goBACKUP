package engine

import (
	"math"
	//"unsafe"
	//"fmt"
	//"github.com/mumax/3/cuda"
	//"github.com/mumax/3/data"
)

func init() {
	//DeclFunc("ext_mdwband", mDWBand, "magnetization of DW band cells")
	DeclFunc("ext_bandanglesxy", BandAnglesXY, "In-plane angle of DW band cells")
	DeclFunc("ext_bandanglesz", BandAnglesZ, "Out-of-plane angles of DW band cells")
	DeclFunc("ext_bandlenxy", BandLenXY, "DW band in-plane vector lengths")
	DeclFunc("ext_angularvelocity", AngularVelocity, "Angular velocity of cells")
	DeclFunc("ext_sumthetadot", SumThetaDot, "Sum angular velocity of cells")
	DeclFunc("ext_sumphidot", SumPhiDot, "Sum angular velocity of cells")
}
/*
func mDwBand(indMin [][]int, dx int) [][]float64 {
	if Mesh().Size()[Z] > 1 {
		fmt.Sprintf("ERROR: count zcell > 1. Implemented only for 2D.")
	}
	M := &M
	nx,ny := Mesh().Size()[X],Mesh().Size()[Y]
	absXYDwBand := make([][]float64, nz)
	phiXYDwBand := make([][]float64, nz)
	phiZDwBand := make([][]float64, nz)
	
	for i:=0; i<nz; i++ {
		absXYDwBand[i] = make([]float64, ny)
		phiXYDwBand[i] = make([]float64, ny)
		phiZDwBand[i] = make([]float64, ny)
		
		for j:=0; j<ny; j++ {
			
			for k:=indMin[i][j]-dx; k<indMin[i][j]+dx; k++ {
				m := M.GetCell(k,j,i)
				absXYDwBand[i][j] = math.Sqrt(math.Pow(m[X],2)+math.Pow(m[Y],2))
				phiXYDwBand[i][j] = math.Atan2(m[Y],m[X])
				phiZDwBand[i][j] = math.Acos(m[Z])
			}
		}
	}
	return absXYDwBand, phiXYDwBand, phiZDwBand
}
*/

//func mDWBand(indMin [][]int, dx int) [][]data.Vector  {
	/* 	Input parameters: indMin = index array of DW position,
	 * 	dx = size of the band in cells (+/- dx around DW).
	 * 
	 *  Creates dx sized band around DW and returns magnetization
	 * 	slice.
	*/
	/*
	nx,ny := Mesh().Size()[X],Mesh().Size()[Y]
	DwBand := make([][]data.Vector, ny)
	
	for i:=0; i<ny; i++ {
		DwBand[i] = make([]data.Vector, 2*dx)
		
		for j:=0; j<2*dx; j++ {
			
			for j:=indMin[0][i]-dx; j<indMin[0][i]+dx; j++ {
				m := M.GetCell(j,i,0)
				DwBand[j][i] = m
			}
		}
	}
	return DwBand
}
*/
func BandAnglesXY(indMin [][]int, dx int) [][]float64 {
	
	if Mesh().Size()[Z] > 1 {
		panic("ERROR: count zcell > 1. Implemented only for 2D.")
	}
	
	M := &M
	ny := Mesh().Size()[Y]
	phiXYDwBand := make([][]float64, ny)

	for i:=0; i<ny; i++ {
		phiXYDwBand[i] = make([]float64, 2*dx)
		k := 0
		for j:=indMin[0][i]-dx; j<indMin[0][i]+dx; j++ {
				m := M.GetCell(j,i,0)
				phiXYDwBand[i][k] = math.Atan2(m[Y],m[X])
				k++
		}
	}
	return phiXYDwBand
}

func BandAnglesZ(indMin [][]int, dx int) [][]float64 {
	
	if Mesh().Size()[Z] > 1 {
		panic("ERROR: count zcell > 1. Implemented only for 2D.")
	}
	
	M := &M
	ny := Mesh().Size()[Y]
	phiZDwBand := make([][]float64, ny)

	for i:=0; i<ny; i++ {
		phiZDwBand[i] = make([]float64, 2*dx)
		k := 0
		for j:=indMin[0][i]-dx; j<indMin[0][i]+dx; j++ {
				m := M.GetCell(j,i,0)
				phiZDwBand[i][k] = math.Acos(m[Z])
				k++
		}
	}
	return phiZDwBand
}

func BandLenXY(indMin [][]int, dx int) [][]float64 {
	
	if Mesh().Size()[Z] > 1 {
		panic("ERROR: count zcell > 1. Implemented only for 2D.")
	}
	
	M := &M
	ny := Mesh().Size()[Y]
	LenXYDwBand := make([][]float64, ny)

	for i:=0; i<ny; i++ {
		LenXYDwBand[i] = make([]float64, 2*dx)
		k := 0
		for j:=indMin[0][i]-dx; j<indMin[0][i]+dx; j++ {
				m := M.GetCell(j,i,0)
				LenXYDwBand[i][k] = math.Sqrt(math.Pow(m[X],2)+math.Pow(m[Y],2))
				k++
		}
	}
	return LenXYDwBand
}

func AngularVelocity(angle0, angle1 [][]float64, timeDif float64, dx int) [][]float64 {
	ny := Mesh().Size()[Y]
	phidot := make([][]float64, ny)
	for i:=0; i<ny; i++ {
		phidot[i] = make([]float64, 2*dx)
		for j:=0; j<2*dx; j++ {
			dangle := angle1[i][j] - angle0[i][j]
			if dangle < -math.Pi {
				dangle += math.Pi*2
			}
			if dangle > math.Pi {
				dangle = math.Pi*2 - dangle
			}
			phidot[i][j] = (dangle)/timeDif
		}
	}
	return phidot
}

func SumThetaDot(thetadot [][]float64, dx int) float64 {
	var sum float64 = 0.0
	ny := Mesh().Size()[Y]
	for i:=0; i<ny; i++ {
		for j:=0; j<2*dx; j++ {
				sum += math.Abs(thetadot[i][j])
		}
	}
	return sum
}

func SumPhiDot(phidot, len0, len1 [][]float64, dx int) float64 {
	var sum float64 = 0.0
	ny := Mesh().Size()[Y]
	for i:=0; i<ny; i++ {
		for j:=0; j<2*dx; j++ {
				sum += math.Abs((len1[i][j]+len0[i][j])/2*phidot[i][j])
		}
	}
	return sum
}


